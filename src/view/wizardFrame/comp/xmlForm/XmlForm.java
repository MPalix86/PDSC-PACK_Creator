package view.wizardFrame.comp.xmlForm;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.Line2D;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import javax.swing.JPanel;
import javax.swing.Timer;
import javax.swing.border.EmptyBorder;

import business.OSValidator;
import listeners.wizardFrameListeners.comp.xmlForm.XmlFormListener;
import model.xml.XmlTag;
import net.miginfocom.swing.MigLayout;
import view.comp.utils.ColorUtils;
import view.wizardFrame.comp.xmlForm.comp.TagRow;


public class XmlForm extends JPanel{


	private HashMap<XmlTag,TagRow> tagOpenRowHashMap;
	private HashMap<XmlTag,TagRow> tagCloseRowHashMap;
	private HashMap<XmlTag,Line2D> OpenCloseTagsLinesHashMap;
	private ArrayList<TagRow> tagRowArr;
	private XmlTag root;
	private int rowCounter;
	private XmlFormListener listener;
	
	private final static int LEFT_PADDING = 25;
	private static int INNER_ROW_PADDING ;

	
	
	
	public XmlForm(XmlTag root) {
		if(OSValidator.isMac()) INNER_ROW_PADDING = -13;
		else if(OSValidator.isWindows()) INNER_ROW_PADDING = - 7;
		else INNER_ROW_PADDING = - 13;
		this.setBorder(new EmptyBorder(0,0,0,0));
		this.setBackground(Color.WHITE);
		this.setLayout(new MigLayout("wrap 1" , "" , "[] 0 []"));
		this.root = root;
		this.OpenCloseTagsLinesHashMap = new HashMap<XmlTag,Line2D>();
		this.tagOpenRowHashMap = new HashMap<XmlTag, TagRow>();
		this.tagCloseRowHashMap = new HashMap<XmlTag, TagRow>();
		this.tagRowArr = new ArrayList<TagRow>();
		this.listener = new XmlFormListener(this);
		this.addMouseListener(listener);
		placeComponents();
	}



	private void placeComponents() {
		rowCounter = 1;
		this.removeAll();
		tagRowArr.clear();
		if(this.root != null) paintTag(root,0);
		this.repaint();
		this.revalidate();
	}
	
	
	


	/**
	 * create tag open and close row for every tag and set indentation dynamically
	 * 
	 * @param tag
	 * @param level starting indentation level (usually 0)
	 */
	private void paintTag(XmlTag tag, int level) {
		
		XmlTag parent =  tag;
		/** calculating left border based on levelCounter */
		int leftBorder = level * LEFT_PADDING;
		
		removePanelsThatNeedToBeRecalculated(parent);
		
		TagRow openRow = generateOpenRow(parent);
	
		tagRowArr.add(openRow);
		
		/** setting calculated border */
		openRow.setBorder(new EmptyBorder( INNER_ROW_PADDING, leftBorder, INNER_ROW_PADDING, 0));
		
		openRow.setRowNumber(rowCounter);
		rowCounter++;
		
		this.add(openRow);
		
		int parentLevel = level;

		if( parent.getSelectedChildrenArr() != null && parent.getSelectedChildrenArr().size() > 0 ) {

			/** increases indentation level */
			level++;

			ArrayList<XmlTag> xmlChildren = parent.getSelectedChildrenArr();

			/** iterating trough selected children */
			for(int i = 0; i < xmlChildren.size(); i++) {
				XmlTag child = xmlChildren.get(i);
				/** recursion */
				paintTag(child,level);
			}

			/**
			 * The recursion cause this piece of code above to be executed AFTER that
			 * every tag is opened.
			 * So close tag are generated in inverse way compared to openRows.
			 * This means that first tag to be closed is last tag (opeRow) generated by 
			 * previous piece of code. This cause tags to be closed properly in right way.
			 */
			
			/** calculating left border based on parentLevelCounter for closing tag*/
			leftBorder = parentLevel * LEFT_PADDING;

			TagRow closeRow = generateCloseRow(parent);
			tagRowArr.add(closeRow);
			closeRow.setBorder(new EmptyBorder( INNER_ROW_PADDING, leftBorder, INNER_ROW_PADDING, 0));
			this.add(closeRow);
		}
	}
	
	
	
	
	/**
	 * This function remove panels that needs to be recalculated.
	 * 
	 * To improve performance the function "paintTag" above calculate Tag's rows only for 
	 * new tag, for all other use rows previously calculated simply repositioning it.
	 * 
	 * but the structure of tagRow (both open and close row) change also based on the fact that
	 * tag has or not children .
	 * we need to force "paintTag" to recalculate rows also when tag passes from having to not having
	 * children or vice versa. This happens in two cases.
	 * 
	 * 1)   if tag has children but NOT contains the closeRow , means that user have
	 * 		added (or pasted) a new tag, so in this case the structure of openRow
	 * 		change, to force openRow recalculations we need to remove it from form.
	 * 
	 * 2)  if tag hasn't children but contains closeRow means that user have
	 * 	   removed (or cutted or dragged) a new tag, so in this case the structure of openRow
	 * 	   change, to force openRow recalculations we need to remove it from form.
	 * 
	 * we must use a solution like this because recalculating all rows every time 
	 * from zero takes almost 1 second.
	 *
	 * instead recalculating only rows that really needs to be recalculated the recalculation time
	 * is lowered to few milliseconds.
	 *  
	 * 
	 * see also "generateOpenRow" function in this class
	 * 
	 * @param tag
	 */
	private void removePanelsThatNeedToBeRecalculated(XmlTag tag) {
		if(tag.getSelectedChildrenArr() != null && !this.tagCloseRowHashMap.containsKey(tag)) {
			if (tagCloseRowHashMap.containsKey(tag)) tagCloseRowHashMap.remove(tag);
			if (tagOpenRowHashMap.containsKey(tag)) tagOpenRowHashMap.remove(tag);
		}
		else if(tag.getSelectedChildrenArr() == null && this.tagCloseRowHashMap.containsKey(tag)) {
			if (tagCloseRowHashMap.containsKey(tag)) tagCloseRowHashMap.remove(tag);
			if (tagOpenRowHashMap.containsKey(tag)) tagOpenRowHashMap.remove(tag);
		}
	}
	
	
	
	
	
	/**
	 * create tag open  row for every tag
	 * 
	 * @param tag
	 */
	private TagRow generateOpenRow(XmlTag tag) {
		
		TagRow openRow = null;
		
		if(!tagOpenRowHashMap.containsKey(tag)) {
			openRow = new TagRow(tag,this, TagRow.OPEN_ROW);
			this.tagOpenRowHashMap.put(tag, openRow);
			return openRow;
		}
		openRow = tagOpenRowHashMap.get(tag);
		return openRow;
		

	}
	
	
	
	
	/**
	 * create tag close row for every tag 
	 * 
	 * @param tag
	 */
	private TagRow generateCloseRow (XmlTag tag) {
		TagRow closeRow = null;

		if(!tagCloseRowHashMap.containsKey(tag)) {
			closeRow = new TagRow(tag,this, TagRow.CLOSE_ROW);
			this.tagCloseRowHashMap.put(tag, closeRow);
			return closeRow;
		}
		return tagCloseRowHashMap.get(tag);
	}
	
	
	
	
	/**
	 * Repaint view cause the calculation of new rows or the recalculation of rows 
	 * that needs to be recalculated and update all arrays containing tag row.
	 * 
	 * NOTE :	Note that repaintView use placecomponents that for calculating rows 
	 * 			starting from root tag. This means that this function has the
	 * 			possibility to add new row relatively to new added tags. Beacause 
	 * 			calculate interface starting from root.
	 */
	public void repaintView() {
		restoreComponentsBackGround();
		placeComponents();	
		removeUnusedTagRows();
	}
	
	
	
	
	/**
	 * Removes unused tag rows
	 */
	private void removeUnusedTagRows() {
	 	Iterator<XmlTag> it = tagOpenRowHashMap.keySet().iterator();
	    while (it.hasNext()) {
	        XmlTag t = (XmlTag) it.next();
	        TagRow r = tagOpenRowHashMap.get(t);
	        if(!tagRowArr.contains(r)) it.remove();
	    }
	    
		it = tagCloseRowHashMap.keySet().iterator();
	    while (it.hasNext()) {
	        XmlTag t = (XmlTag) it.next();
	        TagRow r = tagCloseRowHashMap.get(t);
	        if(!tagRowArr.contains(r)) it.remove();
	    }
	}
	
	
	
	
	/**
	 * Starting from rows, verify if tag contained in the row is present in root,
	 * if root does not contains tag, update view removing corresponding rows from interface.
	 * 
	 * NOTE :  this function is not able to add new elements in interface. Can only
	 * 		   update the existing ones
	 */
	public void updateView() {
		Component[] components = this.getComponents();
		for(Component c : components) {
			if(c.getClass().equals(TagRow.class)) {
				TagRow r = (TagRow) c;
				XmlTag t = r.getTag();
				if (!root.containsChild(t)) {
					this.remove(c);
				}
			}
		}
		repaint();
	}
	
	
	
	/**
	 * hide rows relative to passed tag
	 * 
	 * @param tag of which hide rows
	 */
	public void hideTagRows(XmlTag tag) {
		Component[] components = this.getComponents();
		for(Component c : components) {
			if(c.getClass().equals(TagRow.class)) {
				TagRow r = (TagRow) c;
				if (r.getTag().equals(tag)) {
					c.setVisible(false);
					if(tag.getSelectedChildrenArr() != null) {
						tag.getSelectedChildrenArr().forEach(t -> hideTagRows(t));
					}
				}
			}
		}
		repaint();
	}
	
	
	
	
	/**
	 * hide rows relative to passed tag
	 * 
	 * @param tag of which hide rows
	 */
	public void showTagRows(XmlTag tag) {
		Component[] components = this.getComponents();
		for(Component c : components) {
			if(c.getClass().equals(TagRow.class)) {
				TagRow r = (TagRow) c;
				if (r.getTag().equals(tag)) {
					c.setVisible(true);
					if(tag.getSelectedChildrenArr() != null) {
						tag.getSelectedChildrenArr().forEach(t -> showTagRows(t));
					}
				}
			}
		}
		repaint();
	}




	/**
	 * used For generating line that matches open and close row of tag 
	 * 
	 * @param tag 
	 */
	public void drawOpenCloseTagLine(XmlTag tag) {
		TagRow closeRow = getTagCloseRow(tag);
		if (closeRow != null) {
			Graphics g = this.getGraphics();
			Graphics2D g2 = (Graphics2D) g;
			g.setColor(ColorUtils.TAG_COLOR_BRIGHTER);
			TagRow openRow = getTagOpenRow(tag);
			if(openRow != null) {
				Line2D line = new Line2D.Double(
						openRow.getX() + openRow.getBorder().getBorderInsets(openRow).left + 18, 
						openRow.getY()  + openRow.getHeight(), 
						closeRow.getX() + closeRow.getBorder().getBorderInsets(openRow).left + 18,
						closeRow.getY()
				);
				g2.draw(line);
				OpenCloseTagsLinesHashMap.put(tag, line);
			}
		}
	}
	
	
	
	
	
	/**
	 * simple background blink animation based on swing timer
	 * 
	 * @param lineNumber 	row line number
	 * @param bg			background color	
	 * @param blinkTime		blink time
	 */
	public void lineFocusBlink(int lineNumber, Color bg, int blinkTime) {
		
		TagRow row = getTagRowByLineNumber(lineNumber);
		if(row != null) {
			System.out.println(row.getTag().getName());
			scrollRectToVisible(row.getBounds());
			
			Timer timer1 = new Timer(200, new ActionListener() {
				@Override
				public void actionPerformed(ActionEvent e) {
					row.showComp();
				}
				
			});
			
			timer1.setRepeats(false);
			
			Timer timer = new Timer(300,new ActionListener() {
				private int counter;
				
				@Override
				public void actionPerformed(ActionEvent e) {
					row.hideComp();
					timer1.start();
					counter++;
			        if (counter == blinkTime) {
			            ((Timer)e.getSource()).stop();
			        }
				}
			});
			
			timer.start();
		}
	}
	
	
	
	/**
	 * 
	 * @param lineNumber
	 * @return
	 */
	public TagRow getTagRowByLineNumber(int lineNumber) {
		for(int  i = 0; i < this.tagRowArr.size(); i++) {
			TagRow row = tagRowArr.get(i);
			if(lineNumber == row.getRowNumber() ) return row ;
		}
		return null;
	}
	
	
	
	/**
	 * return tag open row corresponding to passed tag
	 * @param tag tag on wich you want to get open row
	 * @return tag row or null
	 */
	public TagRow getTagOpenRow(XmlTag tag) {
		return this.tagOpenRowHashMap.get(tag);
	}
	
	
	
	
	/**
	 * return tag close row corresponding to passed tag
	 * @param tag tag on wich you want to get close row
	 * @return tag row or null
	 */
	public TagRow getTagCloseRow(XmlTag tag) {
		return this.tagCloseRowHashMap.get(tag);
	}
	
	
	
	
	/**
	 * Restore BackGround of all component
	 * 
	 * @return void
	 */
	public void restoreComponentsBackGround() {
	
		tagRowArr.forEach( (r) ->{
			if(r.isBackGroundHiglighted()) r.unsetHighlightBackGround();
			r.repaint();
		});
	}
	
	
	
	
	/**
	 * Restore BackGround of tag with his children
	 */
	public void highlightComponetBckGround(XmlTag tag , Color c){
		if(this.tagOpenRowHashMap.containsKey(tag)) {
			tagOpenRowHashMap.get(tag).highlightBckGround(c);
		}
		if(this.tagCloseRowHashMap.containsKey(tag)) {
			tagCloseRowHashMap.get(tag).highlightBckGround(c);
		}
		if(tag.getSelectedChildrenArr() != null) {
			tag.getSelectedChildrenArr().forEach( t -> highlightComponetBckGround(t, c));
		}
		

	}
	
	
	
	
	/**
	 * remove open close tag line from xmlForm
	 * 
	 * @param tag
	 */
	
	public void removeLine(XmlTag tag) {
		if(OpenCloseTagsLinesHashMap.containsKey(tag)) {
			OpenCloseTagsLinesHashMap.remove(tag);
			repaint();
		}
	}
	
	
	
	
	
	/**
	 * @return the root
	 */
	public XmlTag getRoot() {
		return root;
	}
	

}
